<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="generator" content="Bootply" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Marten - Projections</title>
    <link href="/v3/content/bootstrap.min.css" rel="stylesheet" type="text/css" />
    <link href="/v3/content/prism.css" rel="stylesheet" type="text/css" />
    <link href="/v3/content/theme.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" />

    <link rel="apple-touch-icon" href="/bootstrap/img/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/bootstrap/img/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/bootstrap/img/apple-touch-icon-114x114.png">

    <!-- CSS code from Bootply.com editor -->
    <link href="/v3/content/affix.css" rel="stylesheet" type="text/css" />
</head>

<!-- HTML code from Bootply.com editor -->

<body>
    <a href="https://github.com/jasperfx/marten"><img style="z-index: 5000; position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>

    <nav class="navbar navbar-default navbar-fixed-top" role="banner">
        <div class="container">
            <div class="navbar-header">
                <a href="/marten" class="navbar-brand">Marten 3.13.1</a>
            </div>
            <nav class="collapse navbar-collapse" role="navigation">
                <ul class="nav navbar-nav pull-right">
                    <li>
                        <a href="/v3/getting_started">Getting Started</a>
                    </li>
                    <li>
                        <a href="/v3/documentation">Documentation</a>
                    </li>
                    <li>
                        <a href="/v3/migration_guide">Migration Guide</a>
                    </li>
                    <li>
                        <a href="https://gitter.im/jasperfx/marten?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/jasperfx/marten" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a>
                    </li>
                    <li>
                        <a href="https://twitter.com/marten_lib?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @marten_lib</a>
                        <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
                    </li>
                    <li><a href="/v3/documentation/events/streams" title="Querying Event and Stream Data">Previous</a></li>
                <li><a href="/v3/documentation/events/projections/async_daemon" title="Async Projections Daemon">Next</a></li>
                </ul>
                <div class="navbar-form navbar-left" role="search">
                    <div class="form-group">
                        <input id="search" type="search" class="form-control" placeholder="Search">
                    </div>
                </div>
            </nav>
        </div>
    </nav>
    <div class="container">
        <nav class="navbar-inverse">
            <ol class="breadcrumb"><li><a href="/v3/">Marten</a></li><li><a href="/v3/documentation">Documentation</a></li><li><a href="/v3/documentation/events">Marten as Event Store</a></li><li class="active">Projections</li></ol>
        </nav>
    </div>
    <!--main-->
    <div class="container">
        <div class="row">
            <!--left-->

            <div class="col-md-3" id="leftCol">

                <img src="/v3/content/images/emblem.png" width="80%" align="middle" />
                <br />
                <ul class="nav nav-stacked affix" id="sidebar"></ul>
                <h3 class="no-margin">Next</h3><p><a href="/v3/documentation/events/projections/async_daemon">Async Projections Daemon</a></p>
                    <h3 class="no-margin">Previous</h3><a href="/v3/documentation/events/streams">Querying Event and Stream Data</a></p>
                </ul>
            </div><!--/left-->
            <!--right-->
            <div class="col-md-9">
                <h1>Projections <a href="https://github.com/jasperfx/marten/blob/3.13/documentation/documentation/events/projections/index.md" class="text-muted small pull-right fa fa-github" style="margin-top: 10px"> Edit on GitHub</a></h1>

                <hr />
                <div id="main-pane">
                    <!--Title:Projections-->
<!--Url:projections-->
<div class="alert alert-info">
The Marten community is working to create more samples of event store projections. Check this page again soon. In the meantime, don't forget to just look through the code and our unit tests.
</div>
<p>First, some terminology that we're going to use throughout this section:</p>
<ul>
<li><em>Projection</em> - any strategy for generating &quot;read side&quot; views from the raw event streams</li>
<li><em>Transformation</em> - a type of projection that generates or updates a single read side view for a single event</li>
<li><em>Aggregate</em> - a type of projection that &quot;aggregates&quot; data from multiple events to create a single readside view document</li>
<li><em>Inline Projections</em> - a type of projection that executes as part of any event capture transaction and is stored as a document</li>
<li><em>Async Projections</em> - a type of projection that runs in a background process using an <a href="https://en.wikipedia.org/wiki/Eventual_consistency">eventual consistency</a> strategy, and is stored as a document</li>
<li><em>Live Projections</em> - evaluates a projected view from the raw event data on demand within Marten</li>
</ul>
<h2 id="transformations">Transformations</h2>
<p>Transformations project from one event type to one document. If you want to have certain events projected to a readside document and the relationship is one to one, Marten supports this pattern today with the .Net <code>ITransform</code> interface:</p>
<pre><code class="language-csharp">&#xD;&#xA;public interface ITransform&lt;TEvent, TView&gt;&#xD;&#xA;{&#xD;&#xA;    TView Transform(EventStream stream, Event&lt;TEvent&gt; input);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>As a sample problem, let's say that we're constantly capturing <code>MonsterSlayed</code> events and our system needs to query just this data. You could query directly against the large <code>mt_events</code> table with
<code>IEventStore.Query&lt;MonsterSlayed&gt;()</code>, but it would be more efficient to keep a separate &quot;read side&quot; copy of this data in a new data collection. We could build a new transform class and readside document like this:</p>
<pre><code class="language-csharp">&#xD;&#xA;public class MonsterDefeatedTransform: ITransform&lt;MonsterSlayed, MonsterDefeated&gt;&#xD;&#xA;{&#xD;&#xA;    public MonsterDefeated Transform(EventStream stream, Event&lt;MonsterSlayed&gt; input)&#xD;&#xA;    {&#xD;&#xA;        return new MonsterDefeated&#xD;&#xA;        {&#xD;&#xA;            Id = input.Id,&#xD;&#xA;            Monster = input.Data.Name&#xD;&#xA;        };&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public class MonsterDefeated&#xD;&#xA;{&#xD;&#xA;    public Guid Id { get; set; }&#xD;&#xA;    public string Monster { get; set; }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>Now, we can plug our new transform type above as a projection when we configure our document store like this:</p>
<pre><code class="language-csharp">&#xD;&#xA;var store = DocumentStore.For(_ =&gt;&#xD;&#xA;{&#xD;&#xA;    _.Connection(ConnectionSource.ConnectionString);&#xD;&#xA;    _.DatabaseSchemaName = &quot;monster_defeated&quot;;&#xD;&#xA;&#xD;&#xA;    _.Events.InlineProjections.TransformEvents(new MonsterDefeatedTransform());&#xD;&#xA;});&#xD;&#xA;</code></pre>
<pre><code class="language-csharp">&#xD;&#xA;public void using_live_transformed_events(IDocumentSession session)&#xD;&#xA;{&#xD;&#xA;    var started = new QuestStarted { Name = &quot;Find the Orb&quot; };&#xD;&#xA;    var joined = new MembersJoined { Day = 2, Location = &quot;Faldor&#x27;s Farm&quot;, Members = new string[] { &quot;Garion&quot;, &quot;Polgara&quot;, &quot;Belgarath&quot; } };&#xD;&#xA;    var slayed1 = new MonsterSlayed { Name = &quot;Troll&quot; };&#xD;&#xA;    var slayed2 = new MonsterSlayed { Name = &quot;Dragon&quot; };&#xD;&#xA;&#xD;&#xA;    MembersJoined joined2 = new MembersJoined { Day = 5, Location = &quot;Sendaria&quot;, Members = new string[] { &quot;Silk&quot;, &quot;Barak&quot; } };&#xD;&#xA;&#xD;&#xA;    session.Events.StartStream&lt;Quest&gt;(started, joined, slayed1, slayed2);&#xD;&#xA;    session.SaveChanges();&#xD;&#xA;&#xD;&#xA;    // Our MonsterDefeated documents are created inline&#xD;&#xA;    // with the SaveChanges() call above and are available&#xD;&#xA;    // for querying&#xD;&#xA;    session.Query&lt;MonsterDefeated&gt;().Count()&#xD;&#xA;        .ShouldBe(2);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="aggregates">Aggregates</h2>
<p>Aggregates condense data described by a single stream. As of v1.0, Marten only supports aggregation via .Net classes. Aggregates are calculated upon every request by running the event stream through them, as compared to inline projections, which are computed at event commit time and stored as documents.</p>
<p>The out-of-the box convention is to expose <code>public Apply([Event Type])</code> methods on your aggregate class to do all incremental updates to an aggregate object. This can be customised using <a href="#aggregator-lookup">AggregatorLookup</a>.</p>
<p>Sticking with the fantasy theme, the <code>QuestParty</code> class shown below could be used to aggregate streams of quest data:</p>
<pre><code class="language-csharp">&#xD;&#xA;public class QuestParty&#xD;&#xA;{&#xD;&#xA;    protected readonly IList&lt;string&gt; _members = new List&lt;string&gt;();&#xD;&#xA;&#xD;&#xA;    public string[] Members&#xD;&#xA;    {&#xD;&#xA;        get&#xD;&#xA;        {&#xD;&#xA;            return _members.ToArray();&#xD;&#xA;        }&#xD;&#xA;        set&#xD;&#xA;        {&#xD;&#xA;            _members.Clear();&#xD;&#xA;            _members.AddRange(value);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public IList&lt;string&gt; Slayed { get; } = new List&lt;string&gt;();&#xD;&#xA;&#xD;&#xA;    public void Apply(MembersJoined joined)&#xD;&#xA;    {&#xD;&#xA;        _members.Fill(joined.Members);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public void Apply(MembersDeparted departed)&#xD;&#xA;    {&#xD;&#xA;        _members.RemoveAll(x =&gt; departed.Members.Contains(x));&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public void Apply(QuestStarted started)&#xD;&#xA;    {&#xD;&#xA;        Name = started.Name;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public string Key { get; set; }&#xD;&#xA;&#xD;&#xA;    public string Name { get; set; }&#xD;&#xA;&#xD;&#xA;    public Guid Id { get; set; }&#xD;&#xA;&#xD;&#xA;    public override string ToString()&#xD;&#xA;    {&#xD;&#xA;        return $&quot;Quest party &#x27;{Name}&#x27; is {Members.Join(&quot;, &quot;)}&quot;;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public class QuestFinishingParty: QuestParty&#xD;&#xA;{&#xD;&#xA;    private readonly string _exMachina;&#xD;&#xA;&#xD;&#xA;    public QuestFinishingParty()&#xD;&#xA;    {&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public QuestFinishingParty(string exMachina)&#xD;&#xA;    {&#xD;&#xA;        _exMachina = exMachina;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public void Apply(MembersEscaped escaped)&#xD;&#xA;    {&#xD;&#xA;        if (_exMachina == null)&#xD;&#xA;        {&#xD;&#xA;            throw new NullReferenceException(&quot;Can&#x27;t escape w/o an Ex Machina&quot;);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        _members.RemoveAll(x =&gt; escaped.Members.Contains(x));&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>New in Marten 1.2 is the ability to use <code>Event&lt;T&gt;</code> metadata within your projections, assuming that you're not trying to run the aggregations inline.</p>
<p>The syntax using the built in aggregation technique is to take in <code>Event&lt;T&gt;</code> as the argument to your <code>Apply(event)</code> methods,
where <code>T</code> is the event type you're interested in:</p>
<pre><code class="language-csharp">&#xD;&#xA;public class QuestPartyWithEvents&#xD;&#xA;{&#xD;&#xA;    private readonly IList&lt;string&gt; _members = new List&lt;string&gt;();&#xD;&#xA;&#xD;&#xA;    public string[] Members&#xD;&#xA;    {&#xD;&#xA;        get&#xD;&#xA;        {&#xD;&#xA;            return _members.ToArray();&#xD;&#xA;        }&#xD;&#xA;        set&#xD;&#xA;        {&#xD;&#xA;            _members.Clear();&#xD;&#xA;            _members.AddRange(value);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public IList&lt;string&gt; Slayed { get; } = new List&lt;string&gt;();&#xD;&#xA;&#xD;&#xA;    public void Apply(Event&lt;MembersJoined&gt; joined)&#xD;&#xA;    {&#xD;&#xA;        _members.Fill(joined.Data.Members);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public void Apply(Event&lt;MembersDeparted&gt; departed)&#xD;&#xA;    {&#xD;&#xA;        _members.RemoveAll(x =&gt; departed.Data.Members.Contains(x));&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public void Apply(Event&lt;QuestStarted&gt; started)&#xD;&#xA;    {&#xD;&#xA;        Name = started.Data.Name;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public string Name { get; set; }&#xD;&#xA;&#xD;&#xA;    public Guid Id { get; set; }&#xD;&#xA;&#xD;&#xA;    public override string ToString()&#xD;&#xA;    {&#xD;&#xA;        return $&quot;Quest party &#x27;{Name}&#x27; is {Members.Join(&quot;, &quot;)}&quot;;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<h3 id="aggregates-across-multiple-streams">Aggregates Across Multiple Streams</h3>
<p>Example coming soon, and check <a href="http://jeremydmiller.com">Jeremy's blog</a> for a sample soon.</p>
<p>It's possible currently by using either a custom <code>IProjection</code> or using the existing aggregation capabilities with a
custom <code>IAggregateFinder&lt;T&gt;</code>, where <code>T</code> is the projected view document type.</p>
<h3 id="aggregator-lookup">Aggregator Lookup</h3>
<p><code>EventGraph.UseAggregatorLookup(IAggregatorLookup aggregatorLookup)</code> can be used to register an <code>IAggregatorLookup</code> that is used to look up <code>IAggregator&lt;T&gt;</code> for aggregations. This allows a generic aggregation strategy to be used, rather than registering aggregators case-by-case through <code>EventGraphAddAggregator&lt;T&gt;(IAggregator&lt;T&gt; aggregator)</code>.</p>
<p>A shorthand extension method <code>EventGraph.UseAggregatorLookup(this EventGraph eventGraph, AggregationLookupStrategy strategy)</code> can be used to set default aggregation lookup, whereby</p>
<ul>
<li><code>AggregationLookupStrategy.UsePublicApply</code> resolves aggregators that use public Apply</li>
<li><code>AggregationLookupStrategy.UsePrivateApply</code> resolves aggregators that use private Apply</li>
<li><code>AggregationLookupStrategy.UsePublicAndPrivateApply</code> resolves aggregators that use public or private Apply</li>
</ul>
<p>The aggregation lookup can also be set in the <code>StoreOptions.Events.UserAggregatorLookup</code></p>
<pre><code class="language-csharp">&#xD;&#xA;// Registering an aggregator lookup that provides aggregator supporting private Apply([Event Type]) methods&#xD;&#xA;theGraph.UseAggregatorLookup(AggregationLookupStrategy.UsePrivateApply);&#xD;&#xA;</code></pre>
<h3 id="live-aggregation-via.net">Live Aggregation via .Net</h3>
<p>You can always fetch a stream of events and build an aggregate completely live from the current event data by using this syntax:</p>
<pre><code class="language-csharp">&#xD;&#xA;using (var session = store.OpenSession())&#xD;&#xA;{&#xD;&#xA;    // questId is the id of the stream&#xD;&#xA;    var party = session.Events.AggregateStream&lt;QuestParty&gt;(questId);&#xD;&#xA;    Console.WriteLine(party);&#xD;&#xA;&#xD;&#xA;    var party_at_version_3 = session.Events&#xD;&#xA;        .AggregateStream&lt;QuestParty&gt;(questId, 3);&#xD;&#xA;&#xD;&#xA;    var party_yesterday = session.Events&#xD;&#xA;        .AggregateStream&lt;QuestParty&gt;(questId, timestamp: DateTime.UtcNow.AddDays(-1));&#xD;&#xA;}&#xD;&#xA;</code></pre>
<p>There is also a matching asynchronous <code>AggregateStreamAsync()</code> mechanism as well. Additionally, you can do stream aggregations in batch queries with
<code>IBatchQuery.Events.AggregateStream&lt;T&gt;(streamId)</code>.</p>
<h2 id="inline-projections">Inline Projections</h2>
<p><em>First off, be aware that event metadata (e.g. stream version and sequence number) are not available duing the execution of inline projections. If you need to use event metadata in your projections, please use asynchronous or live projections.</em></p>
<p>If you would prefer that the projected aggregate document be updated <em>inline</em> with the events being appended, you simply need to register the aggregation type in the <code>StoreOptions</code> upfront when you build up your document store like this:</p>
<pre><code class="language-csharp">&#xD;&#xA;var store = DocumentStore.For(_ =&gt;&#xD;&#xA;{&#xD;&#xA;    _.Connection(ConnectionSource.ConnectionString);&#xD;&#xA;    _.Events.TenancyStyle = tenancyStyle;&#xD;&#xA;    _.DatabaseSchemaName = &quot;quest_sample&quot;;&#xD;&#xA;&#xD;&#xA;    // This is all you need to create the QuestParty projected&#xD;&#xA;    // view&#xD;&#xA;    _.Events.InlineProjections.AggregateStreamsWith&lt;QuestParty&gt;();&#xD;&#xA;});&#xD;&#xA;</code></pre>
<p>At this point, you would be able to query against <code>QuestParty</code> as just another document type.</p>
<h2 id="rebuilding-projections">Rebuilding Projections</h2>
<p>Projections need to be rebuilt when the code that defines them changes in a way that requires events to be reapplied in order to maintain correct state. Using an <code>IDaemon</code> this is easy to execute on-demand:</p>
<pre><code class="language-csharp">&#xD;&#xA;using (var daemon = theStore.BuildProjectionDaemon(logger: _logger, settings: new DaemonSettings&#xD;&#xA;{&#xD;&#xA;    LeadingEdgeBuffer = 0.Seconds()&#xD;&#xA;}))&#xD;&#xA;{&#xD;&#xA;    await daemon.Rebuild&lt;ActiveProject&gt;().ConfigureAwait(false);&#xD;&#xA;}&#xD;&#xA;</code></pre>
<div class="alert alert-warning">
<b><u>Warning:</u></b>
<br />
Marten by default while creating new object tries to use <b>default constructor</b>. <br />
Default constructor doesn't have to be public, might be also private or protected. <br />
If class does not have the default constructor then it creates an uninitialized object (see <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatterservices.getuninitializedobject?view=netframework-4.8" target="_parent">more</a>).<br />
Because of that, no member initializers will be run so all of them need to be initialized in the event handler methods.
</div>

                </div>
                <hr />
                <nav class="related-links">
                    <span>
                        <strong>Previous: </strong><a href="/v3/documentation/events/streams">Querying Event and Stream Data</a>
                    </span>
                    <span class="pull-right">
                        <strong>Next: </strong><a href="/v3/documentation/events/projections/async_daemon">Async Projections Daemon</a>
                    </span>
                </nav>
            </div><!--/right-->
        </div><!--/row-->
    </div><!--/container-->
    <footer>
        <ul>
            <li>
                <a href="https://dotnetfoundation.org">
                    <img class="dot-net-foundation-logo" src="https://raw.githubusercontent.com/dotnet/swag/master/logo/dotnetfoundation_v4.png" alt="Supported by the .NET Foundation" />
                </a>
                Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
            </li>
        </ul>
    </footer>
</body>

<foot>
    <script type='text/javascript' src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script type='text/javascript' src="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/v3/content/prism.js"></script>
    <script type="text/javascript" src="/v3/content/sidebar.js"></script>
    <script type="text/javascript" src="/v3/content/affix.js"></script>

    <script>
        $('#search').keyup(function (e) {
            if (e.keyCode == 13) {
                var search = $('#search').val();

                var url = 'https://www.google.com/#q=site:jasperfx.github.io ' + search;
                url = encodeURI(url);

                //alert(url);

                window.location.href = url;

                e.stopPropagation();
                if (e.cancelBubble != null) e.cancelBubble = true;
                return false;
            }

        });
    </script>
</foot>
</html>
