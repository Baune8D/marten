<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="generator" content="Bootply" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Marten - Diagnostics and Instrumentation</title>
    <link href="/v3/content/bootstrap.min.css" rel="stylesheet" type="text/css" />
    <link href="/v3/content/prism.css" rel="stylesheet" type="text/css" />
    <link href="/v3/content/theme.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" />

    <link rel="apple-touch-icon" href="/bootstrap/img/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/bootstrap/img/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/bootstrap/img/apple-touch-icon-114x114.png">

    <!-- CSS code from Bootply.com editor -->
    <link href="/v3/content/affix.css" rel="stylesheet" type="text/css" />
</head>

<!-- HTML code from Bootply.com editor -->

<body>
    <a href="https://github.com/jasperfx/marten"><img style="z-index: 5000; position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>

    <nav class="navbar navbar-default navbar-fixed-top" role="banner">
        <div class="container">
            <div class="navbar-header">
                <a href="/marten" class="navbar-brand">Marten 3.13.1</a>
            </div>
            <nav class="collapse navbar-collapse" role="navigation">
                <ul class="nav navbar-nav pull-right">
                    <li>
                        <a href="/v3/getting_started">Getting Started</a>
                    </li>
                    <li>
                        <a href="/v3/documentation">Documentation</a>
                    </li>
                    <li>
                        <a href="/v3/migration_guide">Migration Guide</a>
                    </li>
                    <li>
                        <a href="https://gitter.im/jasperfx/marten?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/jasperfx/marten" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a>
                    </li>
                    <li>
                        <a href="https://twitter.com/marten_lib?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @marten_lib</a>
                        <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
                    </li>
                    <li><a href="/v3/documentation/documents/advanced" title="Advanced Topics">Previous</a></li>
                <li><a href="/v3/documentation/documents/command-timeouts" title="Command Timeouts">Next</a></li>
                </ul>
                <div class="navbar-form navbar-left" role="search">
                    <div class="form-group">
                        <input id="search" type="search" class="form-control" placeholder="Search">
                    </div>
                </div>
            </nav>
        </div>
    </nav>
    <div class="container">
        <nav class="navbar-inverse">
            <ol class="breadcrumb"><li><a href="/v3/">Marten</a></li><li><a href="/v3/documentation">Documentation</a></li><li><a href="/v3/documentation/documents">Marten as Document Db</a></li><li class="active">Diagnostics and Instrumentation</li></ol>
        </nav>
    </div>
    <!--main-->
    <div class="container">
        <div class="row">
            <!--left-->

            <div class="col-md-3" id="leftCol">

                <img src="/content/images/emblem.png" width="80%" align="middle" />
                <br />
                <ul class="nav nav-stacked affix" id="sidebar"></ul>
                <h3 class="no-margin">Next</h3><p><a href="/v3/documentation/documents/command-timeouts">Command Timeouts</a></p>
                    <h3 class="no-margin">Previous</h3><a href="/v3/documentation/documents/advanced">Advanced Topics</a></p>
                </ul>
            </div><!--/left-->
            <!--right-->
            <div class="col-md-9">
                <h1>Diagnostics and Instrumentation <a href="https://github.com/jasperfx/marten/blob/3.13/documentation/documentation/documents/diagnostics.md" class="text-muted small pull-right fa fa-github" style="margin-top: 10px"> Edit on GitHub</a></h1>

                <hr />
                <div id="main-pane">
                    <!--Title:Diagnostics and Instrumentation-->
<!--Url:diagnostics-->
<p>So far, Marten has diagnostics, command logging, and unit of work life cycle tracking.</p>
<p>For information on accessing and previewing the database schema objects generated by Marten, see <a href="/v3/documentation/schema">Marten and the Postgresql Schema</a></p>
<h2 id="listening-for-document-store-events">Listening for Document Store Events</h2>
<p><strong>All of the functionality in this section was added as part of Marten v0.8</strong></p>
<p>Marten has a facility for listening and even intercepting document persistence events with the <code>IDocumentSessionListener</code> interface:</p>
<pre><code class="language-csharp">&#xD;&#xA;public interface IDocumentSessionListener&#xD;&#xA;{&#xD;&#xA;    void BeforeSaveChanges(IDocumentSession session);&#xD;&#xA;&#xD;&#xA;    Task BeforeSaveChangesAsync(IDocumentSession session, CancellationToken token);&#xD;&#xA;&#xD;&#xA;    void AfterCommit(IDocumentSession session, IChangeSet commit);&#xD;&#xA;&#xD;&#xA;    Task AfterCommitAsync(IDocumentSession session, IChangeSet commit, CancellationToken token);&#xD;&#xA;&#xD;&#xA;    void DocumentLoaded(object id, object document);&#xD;&#xA;&#xD;&#xA;    void DocumentAddedForStorage(object id, object document);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>You can build and inject your own listeners by adding them to the <code>StoreOptions</code> object you use to configure a <code>DocumentStore</code>:</p>
<pre><code class="language-csharp">&#xD;&#xA;var stub1 = new StubDocumentSessionListener();&#xD;&#xA;var stub2 = new StubDocumentSessionListener();&#xD;&#xA;&#xD;&#xA;using (var store = SeparateStore(_ =&gt;&#xD;&#xA;{&#xD;&#xA;    _.Connection(ConnectionSource.ConnectionString);&#xD;&#xA;    _.AutoCreateSchemaObjects = AutoCreate.All;&#xD;&#xA;}))&#xD;&#xA;</code></pre>
<p>The listeners can be used to modify an <code>IDocumentSession</code> and its related unit of work just before persisting. Marten itself will be using this mechanism
internally to perform projections in the future.</p>
<p>The following fake, sample listener demonstrates how you can query into the pending changes before making a transactional commit, and also how to
query what was done after a commit is made:</p>
<pre><code class="language-csharp">&#xD;&#xA;// DocumentSessionListenerBase is a helper abstract class in Marten&#xD;&#xA;// with empty implementations of each method you may find helpful&#xD;&#xA;public class SimpleSessionListener: DocumentSessionListenerBase&#xD;&#xA;{&#xD;&#xA;    public override void BeforeSaveChanges(IDocumentSession session)&#xD;&#xA;    {&#xD;&#xA;        // Use pending changes to preview what is about to be&#xD;&#xA;        // persisted&#xD;&#xA;        var pending = session.PendingChanges;&#xD;&#xA;&#xD;&#xA;        // Careful here, Marten can only sort documents into &quot;inserts&quot; or &quot;updates&quot; based&#xD;&#xA;        // on whether or not Marten had to assign a new Id to that document upon DocumentStore()&#xD;&#xA;        pending.InsertsFor&lt;User&gt;()&#xD;&#xA;            .Each(user =&gt; Debug.WriteLine($&quot;New user: {user.UserName}&quot;));&#xD;&#xA;&#xD;&#xA;        pending.UpdatesFor&lt;User&gt;()&#xD;&#xA;            .Each(user =&gt; Debug.WriteLine($&quot;Updated user {user.UserName}&quot;));&#xD;&#xA;&#xD;&#xA;        pending.DeletionsFor&lt;User&gt;()&#xD;&#xA;            .Each(d =&gt; Debug.WriteLine(d));&#xD;&#xA;&#xD;&#xA;        // This is a convenience method to find all the pending events&#xD;&#xA;        // organized into streams that will be appended to the event store&#xD;&#xA;        pending.Streams()&#xD;&#xA;            .Each(s =&gt; Debug.WriteLine(s));&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override void AfterCommit(IDocumentSession session, IChangeSet commit)&#xD;&#xA;    {&#xD;&#xA;        // See what was just persisted, and possibly carry out post&#xD;&#xA;        // commit actions&#xD;&#xA;&#xD;&#xA;        var last = commit;&#xD;&#xA;&#xD;&#xA;        last.Updated.Each(x =&gt; Debug.WriteLine($&quot;{x} was updated&quot;));&#xD;&#xA;        last.Deleted.Each(x =&gt; Debug.WriteLine($&quot;{x} was deleted&quot;));&#xD;&#xA;        last.Inserted.Each(x =&gt; Debug.WriteLine($&quot;{x} was inserted&quot;));&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>As of Marten 1.4, you can also register <code>IDocumentSessionListener</code> objects scoped to a particular session with the
<code>DocumentStore.OpenSession(SessionOptions)</code> signature.</p>
<h2 id="custom-logging">Custom Logging</h2>
<p>Marten v0.8 comes with a new mechanism to plug in custom logging to the <code>IDocumentStore</code>, <code>IQuerySession</code>, and <code>IDocumentSession</code> activity:</p>
<pre><code class="language-csharp">&#xD;&#xA;public interface IMartenLogger&#xD;&#xA;{&#xD;&#xA;    IMartenSessionLogger StartSession(IQuerySession session);&#xD;&#xA;&#xD;&#xA;    void SchemaChange(string sql);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public interface IMartenSessionLogger&#xD;&#xA;{&#xD;&#xA;    void LogSuccess(NpgsqlCommand command);&#xD;&#xA;&#xD;&#xA;    void LogFailure(NpgsqlCommand command, Exception ex);&#xD;&#xA;&#xD;&#xA;    void RecordSavedChanges(IDocumentSession session, IChangeSet commit);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>To apply these logging abstractions, you can either plug your own <code>IMartenLogger</code> into the <code>StoreOptions</code> object and allow that default logger to create the individual session loggers:</p>
<pre><code class="language-csharp">&#xD;&#xA;var store = DocumentStore.For(_ =&gt;&#xD;&#xA;{&#xD;&#xA;    _.Logger(new ConsoleMartenLogger());&#xD;&#xA;});&#xD;&#xA;</code></pre>
<p>You can also directly apply a session logger to any <code>IQuerySession</code> or <code>IDocumentSession</code> like this:</p>
<pre><code class="language-csharp">&#xD;&#xA;using (var session = store.OpenSession())&#xD;&#xA;{&#xD;&#xA;    // Replace the logger for only this one session&#xD;&#xA;    session.Logger = new RecordingLogger();&#xD;&#xA;}&#xD;&#xA;</code></pre>
<p>The session logging is a different abstraction specifically so that you <em>could</em> track database commands issued per session. In effect, my own shop is going to use this capability to understand what HTTP endpoints or service bus message handlers are being unnecessarily chatty in their database interactions. We also hope that the contextual logging of commands per document session makes it easier to understand how our systems behave.</p>
<pre><code class="language-csharp">&#xD;&#xA;public class ConsoleMartenLogger: IMartenLogger, IMartenSessionLogger&#xD;&#xA;{&#xD;&#xA;    public IMartenSessionLogger StartSession(IQuerySession session)&#xD;&#xA;    {&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public void SchemaChange(string sql)&#xD;&#xA;    {&#xD;&#xA;        Console.WriteLine(&quot;Executing DDL change:&quot;);&#xD;&#xA;        Console.WriteLine(sql);&#xD;&#xA;        Console.WriteLine();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public void LogSuccess(NpgsqlCommand command)&#xD;&#xA;    {&#xD;&#xA;        Console.WriteLine(command.CommandText);&#xD;&#xA;        foreach (var p in command.Parameters.OfType&lt;NpgsqlParameter&gt;())&#xD;&#xA;        {&#xD;&#xA;            Console.WriteLine($&quot;  {p.ParameterName}: {p.Value}&quot;);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public void LogFailure(NpgsqlCommand command, Exception ex)&#xD;&#xA;    {&#xD;&#xA;        Console.WriteLine(&quot;Postgresql command failed!&quot;);&#xD;&#xA;        Console.WriteLine(command.CommandText);&#xD;&#xA;        foreach (var p in command.Parameters.OfType&lt;NpgsqlParameter&gt;())&#xD;&#xA;        {&#xD;&#xA;            Console.WriteLine($&quot;  {p.ParameterName}: {p.Value}&quot;);&#xD;&#xA;        }&#xD;&#xA;        Console.WriteLine(ex);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public void RecordSavedChanges(IDocumentSession session, IChangeSet commit)&#xD;&#xA;    {&#xD;&#xA;        var lastCommit = commit;&#xD;&#xA;        Console.WriteLine(&#xD;&#xA;            $&quot;Persisted {lastCommit.Updated.Count()} updates, {lastCommit.Inserted.Count()} inserts, and {lastCommit.Deleted.Count()} deletions&quot;);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="accessing-diagnostics">Accessing Diagnostics</h2>
<p>All the diagnostics are going to be exposed off of the <code>IDocumentStore.Diagnostics</code> property. Today, the only capabilities are to get a preview of the generated storage code or a preview of the ADO.NET code that will be generated for a LINQ query.</p>
<h2 id="previewing-linq-queries">Previewing LINQ Queries</h2>
<p>Let's say that we have a small document type called <code>Trade</code>:</p>
<pre><code class="language-csharp">&#xD;&#xA;public class Trade&#xD;&#xA;{&#xD;&#xA;    public int Id { get; set; }&#xD;&#xA;&#xD;&#xA;    [DuplicateField]&#xD;&#xA;    public double Value { get; set; }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>The <code>[DuplicateField]</code> attribute directs Marten to duplicate the value of <code>Value</code> into a separate database field for more efficient querying. Now, let's say that we want to search for every <code>Trade</code> document with a value of over 2,000, but we want to see the SQL query that Marten will build for that query first:</p>
<pre><code class="language-csharp">&#xD;&#xA;// store is the active IDocumentStore&#xD;&#xA;var queryable = theStore.QuerySession().Query&lt;Trade&gt;().Where(x =&gt; x.Value &gt; 2000);&#xD;&#xA;var cmd = queryable.ToCommand(FetchType.FetchMany);&#xD;&#xA;&#xD;&#xA;Debug.WriteLine(cmd.CommandText);&#xD;&#xA;</code></pre>
<p>The sql string in our debug window for the code above is:</p>
<pre>
select d.data from mt_doc_trade as d where d.value > :arg0
</pre>
<h2 id="previewing-the-postgresql-query-plan">Previewing the PostgreSQL Query Plan</h2>
<p>Marten has a helper to find and preview the <a href="http://www.postgresql.org/docs/9.5/static/using-explain.html">PostgreSQL EXPLAIN plan</a> for a Linq query. Our hope is that this will be a valuable aid to teams who need face performance problems while using Marten. The syntax for fetching the EXPLAIN plan for the Linq query from the previous section is shown below:</p>
<pre><code class="language-csharp">&#xD;&#xA;// Explain() is an extension method off of IQueryable&lt;T&gt;&#xD;&#xA;var plan = queryable.Explain();&#xD;&#xA;Console.WriteLine($&quot;NodeType: {plan.NodeType}&quot;);&#xD;&#xA;Console.WriteLine($&quot;RelationName: {plan.RelationName}&quot;);&#xD;&#xA;Console.WriteLine($&quot;Alias: {plan.Alias}&quot;);&#xD;&#xA;Console.WriteLine($&quot;StartupCost: {plan.StartupCost}&quot;);&#xD;&#xA;Console.WriteLine($&quot;TotalCost: {plan.TotalCost}&quot;);&#xD;&#xA;Console.WriteLine($&quot;PlanRows: {plan.PlanRows}&quot;);&#xD;&#xA;Console.WriteLine($&quot;PlanWidth: {plan.PlanWidth}&quot;);&#xD;&#xA;</code></pre>
<p>The console output for the code below (on my box) was:</p>
<pre>
NodeType: Seq Scan
RelationName: mt_doc_trade
Alias: d
StartupCost: 0
TotalCost: 24.13
PlanRows: 377
PlanWidth: 36
</pre>
<h2 id="request-counting-and-thresholds">Request Counting and Thresholds</h2>
<p>Marten has several facilities for improving system performance by reducing the number of network round trips to the server, but the first step maybe to
just understand what kinds of operations are being chatty in the first place. To that end, Marten exposes the request count for each <code>IQuerySession</code> or <code>IDocumentSession</code> that simply tells you how many commands have been issued to Postgresql by that session:</p>
<pre><code class="language-csharp">&#xD;&#xA;using (var session = theStore.QuerySession())&#xD;&#xA;{&#xD;&#xA;    var users = session.Query&lt;User&gt;().ToList();&#xD;&#xA;    var count = session.Query&lt;User&gt;().Count();&#xD;&#xA;    var any = session.Query&lt;User&gt;().Any();&#xD;&#xA;&#xD;&#xA;    session.RequestCount.ShouldBe(3);&#xD;&#xA;}&#xD;&#xA;</code></pre>
<p>At this point, Marten does not have any built in support for asserting requests per session thresholds like other tools. While I think that we are uncomfortable with that functionality ever being turned on in production, it should be easily feasible to build those kinds of automated threshold testing like &quot;fail the test if there were more than 25 requests issued for any given HTTP request.&quot;</p>
<h2 id="getting-postgresql-server-version">Getting PostgreSQL server version</h2>
<p>Marten provides a helper method to fetch the PostgreSQL server version exposed via <code>IDocumentStore.Diagnostics</code>. This is helpful to enable feature toggles based on features available in PostgreSQL versions or perform any diagnostics.</p>
<pre><code class="language-csharp">&#xD;&#xA;var pgVersion = theStore.Diagnostics.GetPostgresVersion();&#xD;&#xA;</code></pre>

                </div>
                <hr />
                <nav class="related-links">
                    <span>
                        <strong>Previous: </strong><a href="/v3/documentation/documents/advanced">Advanced Topics</a>
                    </span>
                    <span class="pull-right">
                        <strong>Next: </strong><a href="/v3/documentation/documents/command-timeouts">Command Timeouts</a>
                    </span>
                </nav>
            </div><!--/right-->
        </div><!--/row-->
    </div><!--/container-->
    <footer>
        <ul>
            <li>
                <a href="https://dotnetfoundation.org">
                    <img class="dot-net-foundation-logo" src="https://raw.githubusercontent.com/dotnet/swag/master/logo/dotnetfoundation_v4.png" alt="Supported by the .NET Foundation" />
                </a>
                Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
            </li>
        </ul>
    </footer>
</body>

<foot>
    <script type='text/javascript' src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script type='text/javascript' src="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/v3/content/prism.js"></script>
    <script type="text/javascript" src="/v3/content/sidebar.js"></script>
    <script type="text/javascript" src="/v3/content/affix.js"></script>

    <script>
        $('#search').keyup(function (e) {
            if (e.keyCode == 13) {
                var search = $('#search').val();

                var url = 'https://www.google.com/#q=site:jasperfx.github.io ' + search;
                url = encodeURI(url);

                //alert(url);

                window.location.href = url;

                e.stopPropagation();
                if (e.cancelBubble != null) e.cancelBubble = true;
                return false;
            }

        });
    </script>
</foot>
</html>
